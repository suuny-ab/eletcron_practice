## ✅ 已完成里程碑：AI 辅助 Markdown 笔记整理 MVP

### 📝 项目背景与目标

- **背景**：本地使用 Obsidian 编辑笔记，但缺少便捷的 AI 自动排版功能。  
- **目标**：开发一个 Web 应用，实现 `.md` 笔记上传、AI 自动排版及下载。

### 🎯 核心功能范围

- **上传**：支持单个 `.md` 文件上传。  
- **AI 处理**：通过 `langchain` 调用通义千问 API 进行排版。  
- **下载**：生成排版后的 `.md` 文件供下载。

### 🛠️ 技术栈

- **前端**：Jinja2（模板引擎） + 原生 JavaScript  
- **后端**：Python + FastAPI  
- **AI 服务**：`langchain` 1.2.8、`langchain-community` 0.4.1、`dashscope` 1.25.11（通义平台）

### 👤 用户故事

> 作为一名使用 Obsidian 的笔记作者，  
> 我希望能通过一个网页，上传我的 `.md` 笔记文件，  
> 以便让 AI 自动排版，并让我下载排版后的版本。

---

### 🚀 基础功能与流式体验

#### 任务列表

1. **环境与项目初始化**
   - 创建项目目录并初始化 Python 虚拟环境。
   - 安装依赖：`fastapi`, `uvicorn`, `jinja2`, `langchain`, `langchain-community`, `dashscope`。

2. **后端基础搭建**
   - 创建 `main.py` 作为入口文件，并编写测试路由。
   - 实现 `POST /upload` 文件上传接口，用于接收并读取文件内容。

3. **AI 排版服务实现**
   - 在 `services/` 目录下创建 `ai_service.py` 模块。
   - 配置通义千问 API Key（通过环境变量）。
   - 实现 `polish_markdown(md_text: str) -> str` 函数，封装对通义千问的调用逻辑。

4. **后端接口改造**
   - 修改 `/upload` 接口，在接收到文件后，读取原始内容，调用 `polish_markdown` 进行 AI 排版，并将原始内容和排版结果一并返回。

5. **前端页面开发**
   - 在 `templates/` 目录下创建 `upload.html`。
   - 构建 `multipart/form-data` 表单，用于文件选择与提交。
   - 设计结果页面，支持展示原始内容和 AI 排版后的内容，并提供下载按钮。

6. **流式响应与实时预览**
   - **后端**：改造 `/upload` 接口，使用 `StreamingResponse` 和 AI 模型的 `astream()` 方法实现流式响应。
   - **前端**：通过 `fetch` 接收流式数据，实时更新预览区域，并展示处理状态与字符统计。

7. **错误处理与联调**
   - 在后端增加 API Key 错误、网络异常等异常处理逻辑。
   - 前端根据后端返回的错误信息，展示友好的错误提示。
   - 完整测试“上传 → AI 流式处理 → 实时预览 → 下载”的全流程。

#### 验收标准

- [x] 前端页面支持 `.md` 文件上传。  
- [x] 后端接口能成功接收文件并返回原始内容。  
- [x] 后端成功调用通义千问 API，并返回排版后的 Markdown 文本。  
- [x] 前端页面能同时展示原始内容和 AI 排版后的内容。  
- [x] 用户可下载 AI 排版后的文件。  
- [x] 当 API Key 错误或网络异常时，前端能给出友好的错误提示。  
- [x] 整体流程在本地开发环境稳定运行。

---

## 🎯 新需求：AI 提问与文档整理

### 🎯 目标与场景

在现有“上传 → AI 排版 → 下载”流程基础上，新增“AI 提问”能力，形成完整工作流：

> **上传文档 → AI 提问辅助整理 → AI 排版 → 下载笔记**

**典型场景**：
- 用户上传一篇半成品笔记后，与 AI 进行交互，由 AI 辅助完成笔记整理工作。
- 用户与 AI 多轮交互，逐步完善笔记内容。
- 最后对整理好的完整文档进行一键排版，然后下载。

### 🔄 接口与流程调整思路

#### 现有接口分析
当前 `/upload` 接口职责过重，集成了文件上传、AI 排版、流式返回等多个功能，不利于后续扩展。

#### 调整方向
1. **拆分职责**：将单一接口拆分为职责更单一的多个接口。
2. **文档存储**：为上传的文档存储在服务器，使后续操作能基于已上传的文档进行，而非重复上传文件内容。

#### 潜在新接口设计
- **`POST /upload`**：仅负责接收文件，进行基础校验，并将文档存储在服务器。
- **`POST /chat`**：读取服务器中暂存的文档内容和用户的提问，调用大模型进行交互。此接口也可设计为流式输出，实现边问边看的效果。
- **`POST /polish`**：读取文档，对已暂存的文档内容进行排版，并返回或流式传输排版结果。
- **`GET /download`**：获取最终处理后的文档，并可选择删除暂存文档。

### 💾 文档暂存方案考量

#### 暂存策略
- **存储方式**：初期可使用本地临时目录。后续若服务器文件系统无法满足需求，可升级为数据库或对象存储。
- **生命周期**：为暂存文档设置最短生命周期，例如用户下载后即刻删除。若后续需求变动需要长期存储，再进行调整。

### 🤔 其他问题

1. **交互模式**：AI 提问是采用“一问一答”的简单模式，还是支持“多轮对话”的会话模式？  
   - **方案**：先采用一问一答的简单实现，等功能稳定后再实现多轮对话模式。

2. **上下文管理**：如何管理多轮对话的上下文？是仅基于当前文档，还是结合历史对话？  
   - **方案**：需要结合历史对话。LangChain 提供了方便的对话历史管理接口，可用于维护上下文。

3. **接口幂等性**：对于重试或刷新页面的场景，如何确保接口调用的幂等性，避免重复处理？  
   - **方案**：幂等性问题是为了防止前端用户多次点击产生的对后端接口的重复调用，现在的几个接口多次点击后并不产生严重后果，等所有功能完成后再来考虑接口幂等性问题。

4. **前端状态同步**：前端如何维护文档的多个版本（原始版、提问整理版、排版版）及其对应的状态？  
   - **方案**：采用双栏界面设计，按流程分步操作：
     - **左侧**：只读展示原始内容。
     - **右侧**：初始为空，等待 AI 输出提问整理版。用户可在右侧编辑笔记，满意后点击“暂存”，用右侧内容覆盖左侧。
     - **流程**：暂存后，用户可继续提问整理。最终满意后，点击“暂存”再执行“自动排版”，在右侧展示最终排版版。此方案暂不支持版本回退。

---

### 迭代一：拆分后端接口

原工作流中，上传接口同时处理文件上传、AI 排版和流式响应。  
新工作流如下：

1. 用户在前端上传待排版文档到服务器。
2. 用户点击“自动排版”按钮，前端调用后端排版接口。
3. 后端流式返回 AI 排版结果，前端实时展示。
4. 排版完成后，前端显示下载按钮。
5. 用户点击下载，前端获取完整结果并调用删除接口，清理临时文件。

**接口变更**：
- **上传接口**：仅将文件暂存在指定文件夹，避免重复上传。
- **新增排版接口**：流式返回 AI 排版结果。
- **新增删除接口**：用户下载后调用，删除服务器上的临时文档。

#### 验收标准
- [x] 后端现在有三个接口：上传、流式响应的排版、删除。
- [x] 前端按照新的工作流调用这三个接口。

---

### 迭代二：加入 AI 对话能力

在完成接口拆分和文档暂存机制的基础上，引入 AI 对话功能，支持用户与 AI 交互式整理笔记。  
具体实现将基于 `/chat` 接口，结合 LangChain 的对话历史管理能力，逐步构建多轮问答与内容优化闭环。

#### 工作流演进

**原工作流**：  
用户上传笔记 → 服务器暂存 → 点击自动排版 → 后端流式返回排版结果 → 前端展示 → 用户下载并清理临时文件。

**新工作流（第一阶段）**：  
提供不带对话记忆的辅助笔记整理功能，包含两种形式：

- **AI 修改形式**：AI 直接生成修改后的完整文档，前端实时渲染。用户可在 AI 修改基础上继续编辑，点击“暂存”覆盖原有内容（但不下载）。适用于用户明确知道如何修改笔记的场景。
- **AI 建议形式**：AI 不直接修改文档，而是给出建议。前端实时渲染建议内容，不改变笔记正文。用户根据建议手动修改，点击“暂存”完成本轮整理。

**整体流程**：  
用户上传半成品笔记 → 使用 AI 辅助整理（修改或建议）→ 满意后暂存 →执行多轮辅助整理直到用户满意→ 执行一键排版 → 下载最终版本。

#### 界面更新建议

当前界面将上传、预览、排版、下载集中于单页，布局不够合理。随着功能增多，需重构为专用笔记处理页面：

- **适配限制**：仅支持桌面端，不支持移动端。
- **布局结构**：三栏式全屏布局（不可上下滚动），模拟桌面编辑器体验：
  - **左侧栏**：只读预览原始笔记。上传后显示原始内容；用户点击“暂存”后，用新内容覆盖此处。
  - **中间栏**：主编辑区。初始显示原始内容；AI 输出或用户编辑均在此区域生效。支持切换 **编辑模式** 与 **预览模式**。
  - **右侧栏**：AI 功能面板。包含“AI 建议”、“AI 修改”、“一键排版”等操作按钮，预留未来 AI 功能扩展位。

> 此设计聚焦清晰的工作流引导与高效的双版本对比，提升用户整理笔记的体验。


页面更新完成后，接下来加入给后端加入chat接口，chat接口接受前端传回来的用户问题，然后读取暂存在文件系统的文件，将问题和文件内容组合，作为大模型的输入。
大模型输出建议供用户查看
这时需要注意到，需要将暂存按钮改为保存按钮，点击按钮后将修改内容保存回服务器的文件系统。同时覆盖前端的旧版本。
先加入建议chat接口

现在需要重构后端架构，采用分层架构，分为api层，服务层，ai引擎层
依赖关系时，api层调用服务层实现业务，服务层编排业务逻辑，调用ai引擎层提供的ai服务